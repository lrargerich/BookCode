package edu.stanford.math.plex4.streams.interfaces;

import java.util.Comparator;

import edu.stanford.math.plex4.homology.barcodes.Interval;
import edu.stanford.math.plex4.homology.barcodes.PersistenceInvariantDescriptor;


/**
 * <p>This interface defines the functionality of a streamed filtered
 * chain complex. An implementing class must provide functionality
 * for iterating through the chain complex, as well as providing
 * information about the basis elements (such as their filtration
 * indices and dimension).</p>
 * 
 * <p>Note that there are two types of grading on our notion of a 
 * filtered chain complex. The first is that of the filtration index.
 * In other words we have the decomposition
 * <code>... -> C_{i-1} -> C_{i} -> C_{i+1} -> ...</code>
 * with elements in C_i having the filtration index given by a_i. However, 
 * we also have the more standard homological grading given by the "dimension"
 * of a basis element. Since we are not restricting ourselves to basis
 * elements consisting of simplices, the dimension may or may not carry
 * geometric meaning. Nevertheless it plays an important role.</p>
 * 
 * <p>An implementing class must iterate through the basis elements in 
 * non-decreasing order of filtration index. This defines a partial
 * order on the set of basis elements within the entire chain complex.
 * The completion of this partial order to a total order can depend
 * on the implementer, but must be such that the boundary of a basis 
 * element must always precede the element itself. In practice, the 
 * completion of the partial order will be based on dimension.</p>
 * 
 * <p>The underlying type of the stream, T, will vary depending on the
 * context. Below are some examples:
 * <ul>
 * <li>T = Simplex: a standard filtered simplicial complex</li>
 * <li>T = Cell: a standard filtered CW complex</li>
 * <li>T = ObjectObjectPair<T, U>: a pair may represent a tensor product</li>
 * </ul>
 * </p>
 * 
 * <p>This interface is the highest level in the filtered stream classes
 * and interfaces, and defines the basic functionality that all such
 * streams must implement.</p>
 * 
 * <p>It is important to note that functions such as getBoundary, 
 * getFiltrationIndex and getDimension do not only depend on the 
 * queried basis element (ie. the simplex in question), but also 
 * the properties of the chain complex. For example, the getBoundary
 * function may return the coboundary of a simplex rather than a 
 * boundary in the case that we are working in the context of a cochain
 * complex. Or, the getDimension may return a shifted version of
 * the actual geometric dimension of a simplex.</p>
 * 
 * <p>Another important point is that this class is agnostic towards the
 * actual filtration value of a basis element, and only stores filtration
 * indices. Filtration indices are integers that are somehow calculated from
 * the actual filtration values. The reason that we have chosen not to store
 * the actual filtration values is that we do not want to enforce a particular
 * ordering on them. For example, we may define a filtered complex based on 
 * the sublevel or superlevel sets of a function. However, we always maintain
 * the constraint that the filtration index must be non-decreasing.</p>
 * 
 * <p>A note on language: We call the underlying parameterized type T as the
 * basis type. This is justified by the fact that the modules in the chain
 * complex are free modules, and are generated by objects with type T.</p>
 * 
 * @author Andrew Tausz
 *
 * @param <T> the underlying type of the generators in the free modules of the complex
 */
public interface AbstractFilteredStream<T> extends Iterable<T> {
	
	/**
	 * This function returns the filtration index of the requested basis element.
	 * 
	 * @param basisElement the basis element to get the filtration index for
	 * @return the filtration index of the specified basis element
	 */
	public int getFiltrationIndex(T basisElement);
	
	public double getFiltrationValue(T basisElement);
	
	/**
	 * This function returns whether an element is contained in the stream.
	 * 
	 * @param basisElement the basis element to be tested
	 */
	public boolean containsElement(T basisElement);

	/**
	 * This function returns the elements in the boundary of the supplied
	 * basisElement, without the coefficients. We do not integrate the
	 * elements of the boundary array with their respective coefficients
	 * since this interface is designed to be independent of the algebraic
	 * environment.
	 * 
	 * @param basisElement the element to get the boundary of
	 * @return an array containing the boundary elements of the queried element
	 */
	public T[] getBoundary(T basisElement);
	
	/**
	 * This function returns the coefficients of the boundary of the supplied
	 * basis element. Note that in many cases, this will be the standard array
	 * consisting of alternating signs: [1, -1, 1, -1, ...]. However, this
	 * will not always be the case. Thus this must be left abstract. Also note
	 * that the coefficients will always be integers.
	 * 
	 * @param basisElement the element to get the boundary coefficients of
	 * @return an array containing the boundary coefficients of the queried element
	 */
	public int[] getBoundaryCoefficients(T basisElement);
	
	/**
	 * This function returns the dimension of a basis element within
	 * the chain complex.
	 * 
	 * @param basisElement the element to get the dimension of
	 * @return the dimension of the basis element within the chain complex
	 */
	public int getDimension(T basisElement);
	
	/**
	 * This function prepares the stream for use by a consumer, such as the
	 * PersistentHomology class. After finalization, the stream cannot not be 
	 * modified by adding or removing elements. In practice, the finalize
	 * procedure will probably do some sorting and construction of data
	 * structures necessary for iterating through the stream.  
	 */
	public void finalizeStream();
	
	/**
	 * This function checks whether the finalize() function has been called.
	 * 
	 * @return true if the stream has been finalized, and false otherwise
	 */
	public boolean isFinalized();
	
	/**
	 * This function returns the total number of elements in the stream.
	 * 
	 * @return the size of the stream
	 */
	public int getSize();
	
	/**
	 * This function gets the maximum filtration index in the complex.
	 * 
	 * @return the maximum filtration index
	 */
	public int getMaximumFiltrationIndex();
	/**
	 * This function gets the minimum filtration index in the complex.
	 * 
	 * @return the minimum filtration index
	 */
	public int getMinimumFiltrationIndex();
	
	/**
	 * This function returns a comparator on the underlying basis type.
	 * 
	 * @return a comparator on the underlying basis type
	 */
	public Comparator<T> getBasisComparator();
	
	/**
	 * This function transforms the given collection of filtration index barcodes into filtration value barcodes.
	 * 
	 * @param <G>
	 * @param barcodeCollection the set of filtration index barcodes
	 * @return the barcodes transformed into filtration value form
	 */
	public <G> PersistenceInvariantDescriptor<Interval<Double>, G> transform(PersistenceInvariantDescriptor<Interval<Integer>, G> barcodeCollection);
}
